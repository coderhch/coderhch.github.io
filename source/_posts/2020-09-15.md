---
title: Condition：重入锁的好搭档
tags: 
    - java
    - 多线程
    - 锁
date: 2020-09-15
cover: https://coderhch.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2020_02_17_00_41_IMG_0941.JPG
---
# Condition：重入锁的好搭档

如果大家理解了`Object.wait()`方法和`Object.notify()`方法，就能很容易理解**Condition**对象了。它与`wait()`方法和`notify()`方法的作用是大致相同的。但是`wait()`方法和`notify()`方法和`notify()`方法是与**synchronized**关键字合作使用的，而**Condition**是与重入锁相关联的。通过lock接口（重入锁就实现了这一接口）的`Condition newCondition()`方法可以生成一个与当前重入锁绑定的**Condition**实例。利用**Condition**对象，我们就可以让线程在合适的时间等待。或者在某一个特定的时刻得到通知，继续执行。

**Condition**接口提供的基本方法如下：

```java
void await() throws InterruptedException;
void awaitUninterruptibly();
long awaitNanos(long nanosTimeout) throws InterruptedException;
boolean await(long time, TimeUnit unit) throws InterruptedException;
boolean awaitUntil(Date deadline) throws InterruptedException;
void signal();
void signalAll();
```

以下方法的含义如下：

- `await()`方法会使当前线程等待，同时释放当前锁，当其他线程中使用`signal()`方法或者`signalAll()`方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和`Object.wait()`方法类似。
- `awaitUninterruptibly()`方法与`await()`方法基本相同，但是它并不会在等待过程中响应中断。
- `signal()`方法用于唤醒一个在等待中的线程，`signalAll()`方法会唤醒所有在等待中的线程。这和`Object.notify()`方法很类似。

```java
public class ReenterLockCondition implements Runnable{
    public static ReentrantLock lock = new ReentrantLock();
    public static Condition condition=lock.newCondition();
    @Override
    public void run() {
        try {
            lock.lock();
            condition.await();
            System.out.println("Thread is going on");
        }catch (InterruptedException e){
			e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ReenterLockCondition tl=new ReenterLockCondition();
        Thread t1 = new Thread(tl);
        t1.start();
        Thread.sleep(2000);
        //通知线程t1继续执行
        lock.lock();
        condition.signal();
        lock.unlock();
    }
}
```

第3行代码通过**lock**生成一个与之绑定的**Condition**对象。第8行代码要求线程在**Condition**对象上进行等待。第24行代码由主线程main发出通知，告知等待在**Condition**上的线程可以继续执行了。

与`Object.wait()`方法和`notify()`方法一样，当线程使用`Condition.await()`方法时，要求线程持有相关重入锁，在`Condition.await()`方法调用后，这个线程会释放这把锁。同理，在`Condition.signal()`方法调用时，也要求线程先获得相关的锁。在`signal()`方法调用后，系统会从当前**Condition**对象的等待队列中唤醒一个线程。一旦线程被唤醒，它会重新尝试获得与之绑定的重入锁，一旦成功获取，就可以继续执行了。因此，在signal()方法调用之后一般需要释放相关的锁，让给被唤醒的线程，让它可以继续执行。比如，在本案例中，第24行代码就释放了重入锁，如果省略25行，那么，虽然已经唤醒了线程t1，但是由于它无法重新获得锁，因而也就无法真正的继续执行。

