---
title: CyclicBarrier：循环栅栏
tags: 
    - java
    - 多线程
    - 锁
date: 2020-09-18
cover: https://coderhch.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2020_02_24_11_24_IMG_1065.JPG
---
# CyclicBarrier：循环栅栏

**CyclicBarrier**可以理解为循环栅栏。栅栏就是一种障碍物，比如，通常在私人宅邸的周围可以围上一圈栅栏，阻止闲杂人等入内。这里当然就是用来阻止线程继续执行，要求线程在栅栏外等候。前面**Cyclic**意为循环，也就是说这个计数器可以反复使用。比如，我们将计数器设置为10，那么凑齐第一批10个线程后，计数器就会归零，接着凑齐下一批10个线程，这就是循环栅栏内的含义。

**CyclicBarrier**的使用场景也很丰富。比如，司令下达命令，要求10个士兵一起完成一项任务。这时就会要求10个士兵先集合报道，接着，一起雄赳赳，气昂昂地去执行任务。当10个士兵把自己手上的任务都执行完了，那么司令才能对外宣布，任务完成！

**CyclicBarrier**比CountDownLatch略微强大一些，它可以接收一个参数作为**barrierAction**。所谓**barrierAction**就是当计数器一次计数完成后，系统会执行的动作。如下构造函数，其中，**parties**表示计数总数，也就是参与的线程总数。

```java
public CyclicBarrier(int parties, Runnable barrierAction) 
```

下面的示例使用CycLicBarrier演示了上述司令命令士兵完成任务的场景。

```java
public class CyclicBarrierDemo {
    public static class Soldier implements Runnable{
        private String soldier;
        private final CyclicBarrier cyclicBarrier;

        Soldier(CyclicBarrier cyclicBarrier,String soldierName){
            this.cyclicBarrier=cyclicBarrier;
            this.soldier=soldierName;
        }
        @Override
        public void run() {
            try {
                //等待所有士兵到齐
                cyclicBarrier.await();
                doWork();
                cyclicBarrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }
        void doWork(){
            try {
                Thread.sleep(Math.abs(new Random().nextInt()%10000));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(soldierName+"：任务完成");
        }
    }
    public static class BarrierRun implements Runnable{
        boolean flag;
        int N;
        public BarrierRun(boolean flag,int N){
            this.flag=flag;
            this.N=N;
        }
        @Override
        public void run() {
            if (flag){
                System.out.println("司令：[士兵"+N+"个,任务完成！]");
            } else {
                System.out.println("司令：[士兵"+N+"个,集合完毕！]");
                flag=true;
            }
        }
    }
    public static void main(String[] args) {
        final int N = 10;
        Thread[] allSoldier = new Thread[N];
        boolean flag = false;
        CyclicBarrier cyclicBarrier=new CyclicBarrier(N,new BarrierRun(flag,N));
        //设置屏蔽点，主要是为了执行这个方法
        System.out.println("集合队伍！");
        for(int i=0;i<N;i++){
            System.out.println("士兵"+i+"报道！");
            allSoldier[i]=new Thread(new Soldier(cyclicBarrier,"士兵"+i));
            allSoldier[i].start();
        }
    }
}
```

上述代码第53行创建了**CyclicBarrier**实例，并将计数器设置为10，要求在计数器达到指标时，执行第40行的`run()`方法。每一个士兵线程都会执行第11行定义的`run()`方法。在第14行，每一个士兵线程都会等待，直到所有的士兵都集合完毕。集合完毕意味着**CyclicBarrier**的一次计数完成，当再一次`CyclicBarrier.await()`方法时，会进行下一次计数。第15行模拟了士兵的任务。当一个士兵任务执行完，他就会要求**CyclicBarrier**开始下一次计数，这次计数主要目的是监控是否所有的士兵都已经完成了任务，一旦任务全部完成，第35行定义BarrierRun就会被调用，打印相关信息。

```
集合队伍！
士兵0报道！
士兵1报道！
士兵2报道！
士兵3报道！
士兵4报道！
士兵5报道！
士兵6报道！
士兵7报道！
士兵8报道！
士兵9报道！
司令：[士兵10个,集合完毕！]
士兵7：任务完成
士兵4：任务完成
士兵8：任务完成
士兵5：任务完成
士兵1：任务完成
士兵6：任务完成
士兵9：任务完成
士兵0：任务完成
士兵2：任务完成
士兵3：任务完成
司令：[士兵10个,任务完成！]
```

`CyclicBarrier.awit()`方法可能会抛出两个异常。一个是**InterruptedException**，也就是在等待过程中，线程被中断，应该说这是一个非常通用的异常。大部分迫使线程等待的方法都可能会抛出这个异常，使得线程在等待是依然可以响应外部紧急事件。另外一个异常则是**CyclicBarrier**特有的**BrokenBarrierException**。一旦遇到这个异常，则表示当前的**CyclicBarrier**已经破损了，可能系统已经没有办法等待所有线程到齐了。如果继续等待，可能就是徒劳无功，因此，还是“打道回府”吧

