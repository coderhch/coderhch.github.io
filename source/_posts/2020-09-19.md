---
title: 线程池
tags: 
    - java
    - 多线程
    - 线程池
date: 2020-09-19
cover: https://coderhch.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2020_02_26_21_41_IMG_1229.JPG
---
# 线程池

1. 什么是线程池

为了避免系统频繁的创建和销毁线程，我们可以让创建的线程复用。如果大家进行数据库开发，那么对数据库连接池应该不会陌生。为了避免每次数据库查询都重新建立和销毁数据库连接，我们可以使用数据库连接池维护一些数据库连接，让他们长期保持在一个激活转态。当系统需要使用数据库时，并不是创建一个新的连接，而是从连接池中获得一个连接即可。反之，当需要关闭连接时，并不真的把连接关闭，而是将这个连接还给连接池即可。这种方式可以节约不少创建和销毁对象的时间。

2. JDK对线程池的支持

`Executor`框架提供了各种类型的线程池，主要有以下工厂方法：

```java
public static ExecutorService newFixedThreadPool(int nThreads)
public static ExecutorService newSingleThreadExecutor() 
public static ExecutorService newCachedThreadPool()
public static ScheduledExecutorService newSingleThreadScheduledExecutor()
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
```

以上工厂方法分别返回具有不同工作特性的线程池。这些线程池工厂方法具体说明如下：

- `newFixedThreadPool()`方法：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理任务队列中的任务。

- `newSingleThreadExecutor()`方法：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保持在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。

- `newCachedThreadPool()`方法：该方法返回一个可根据实际情况调整线程数量的线程。线程池的数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

- `newSingleThreadScheduledExecutor()`方法：该方法返回一个`ScheduledExecutorService`对象，线程池大小为1。ScheduledExecutorService接口在ExecutorService接口之上扩展了在给定时间执行某任务的功能，如在某个固定的延时之后执行，或者周期性执行某个任务。

- `newScheduledThreadPool()`方法：该方法也返回一个`ScheduledExecutorService`对象，但该线程池可以指定线程数量。

## 固定大小的线程池

这里，我们一`newFixedThreadPool`为例，简单地展示线程池的使用方法：

```java
public class ThreadPoolDemo {
    public static class MyTask implements Runnable{

        @Override
        public void run() {
            System.out.println(System.currentTimeMillis()+":Thread ID:"+Thread.currentThread().getId());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        MyTask task=new MyTask();
        ExecutorService es= Executors.newFixedThreadPool(5);
        for (int i=0;i<10;i++){
            es.submit(task);
        }
    }
}
```

上述代码中，第**17**行创建了固定大小的线程池，内有**5**个线程。在第19行，依次向线程池提交**10**个任务。此后，线程池就会安排调度这10个任务。每个任务都会将自己的执行时间和执行这个线程的ID打印出来，并且在这里，安排每个任务要执行1秒。

执行上述代码，可以得到类似以下输出：

```
1600780260109:Thread ID:14
1600780260109:Thread ID:18
1600780260109:Thread ID:16
1600780260109:Thread ID:17
1600780260109:Thread ID:15
1600780261155:Thread ID:17
1600780261155:Thread ID:16
1600780261155:Thread ID:14
1600780261155:Thread ID:15
1600780261155:Thread ID:18
```

## 计划任务

另外一个值得注意的方法是`newScheduledThreadPool()`。它返回一个`ScheduledExecutorService`对象，可以根据时间需要对线程进行调度。它的一些主要方法如下：

```java
public ScheduledFuture<?> schedule(Runnable command,long delay, TimeUnit unit);
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit);
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay, TimeUnit unit);
```

与其他几个线程池不同，`ScheduledExecutorService`并不一定会立即安排执行任务。它其实是起到了计划任务的作用。它会在指定的时间，对任务进行调度。

方法`schedule()`会给定时间，对任务进行一次调度。方法`scheduleAtFixedRate()`和`scheduleWithFixedDelay()`会对任务进行周期性的调度，但是两者有一点小小的区别。

- `scheduleAtFixedRate`：创建一个周期性任务。任务开始于给定的初始延时。后续的任务按照给定的周期进行；后续第一个任务将会在**initialDelay+period**是执行，后续第二个任务将在**initialDelay+2*period**时进行，以此类推。

- `scheduleWithFixedDelay`：创建并执行一个周期性任务。任务开始于初始延时时间，后续任务将会那种给定的延时进行；即上一个任务的结束时间到下一个任务的开始时间的时间差。

下面的例子使用`scheduleAtFixedRate()`方法调度一个任务。这个任务会执行1秒，调度周期是2秒。也就是说每2秒，任务就会执行一次。

```java
public class ScheduledExecutorServiceDemo {
    public static void main(String[] args) {
        ScheduledExecutorService ses = Executors.newScheduledThreadPool(10);
        ses.scheduleAtFixedRate(new Runnable() {
            
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);
                    System.out.println(System.currentTimeMillis()/1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        },0,2, TimeUnit.SECONDS);
    }
}
```

执行上述代码，一种输出的可能如下：

```
1601078990
1601078992
1601078994
1601078996
1601078998
1601079000
1601079002
1601079004
```

上述输出的单位是秒。可以看到，时间间隔是2秒。

这里还想说一个有意思的事情，如果任务的执行时间超过调度时间会发生什么情况呢？比如，这里调度周期是2秒，如果任务执行时间是8秒，是不是会出现多个任务堆叠在一起呢？

实际上，ScheduledExecutorService不会让任务堆叠出现，我们将第9行的代码改为：

```java
Thread.sleep(8000);
```

再执行上述代码，你就会发现任务的执行周期不再是2秒，而是变成了8秒。如下所示，是一种可能的结果。

```
1601079376
1601079384
1601079392
1601079400
1601079408
```

也就是说，周期如果太短，那么任务就会在上一个任务结束后立即被调用。可以想象，如果采用`scheduleWithFixedDelay`方法，并且按照修改8秒，调度周期2秒，那么任务的实际间隔将是10秒。

另外一个值得注意的问题是，调度程序实际上并不保证任务会无线期地持续调用。如果任务本身抛出了异常，那么后续的所有执行都会被中断，因此，如果你想让你的任务持续稳定的执行，那么做好异常处理非常重要，否则你很可能观察到调度器无疾而终。

注意：如果任务遇到异常，那么后续的所有子任务都会停止调用，因此，必须保证异常被及时处理，为周期性任务的稳定调度提供条件。

## 核心线程池的内部实现

对于核心的几个线程池，无论是`newFixedThreadPool()`，方法`newSingleThreadExecutor()`，还是`newCachedThreadPool()`方法，虽然看起来创建的线程有着完全不同的功能特点，但其内部均使用了**ThreadPoolExecutor**类。下面给出了三个线程池的实现方式：

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
}
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
}
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
}
```

由以上线程池的实现代码可以看到，它们都只能**ThreadPoolExecutor**类的封装。为何ThreadPoolExecutor类有如此强大的功能呢？来看一下ThreadPoolExecutor类最重要的构造函数：

```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) 
```

函数的参数含义如下：

- `corePoolSize`：指定了线程池的线程数量；

- `maximumPoolSize`：指定了线程池中的最大线程数量；

- `keepAliveTime`：当线程池线程数量超过`corePoolSize`时，多余的空闲线程的存活时间，即超过`corePoolSize`的空闲线程，在多长时间内会被销毁；

- `unit`：`keepAliveTime`的单位；

- `workQueue`：任务队列，被提交但尚未被执行的任务；

- `threadFactory`：线程工厂，用于创建线程，一般用默认的即可；

- `handler`：拒绝策略，当任务太多来不及处理时，如何拒绝任务。

以上参数中大部分都很简单，只有参数**workQueue**和**handler**需要进行详细说明。

参数**workQueue**指被提交但为执行的任务队列，它是一个**BlockingQueue**接口的对象，仅用于存放**Runnable**对象。根据队列功能分类，在**ThreadPoolExecutor**类的构造函数中可使用以下几种**BlockingQueue**接口。

直接提交的队列：该功能由**SychronousQueue**对象提供。**SychronousQueue**是一个特殊的**BlockingQueue**。**SychronousQueue**没有容量，每一个插入操作都要等待一个相应的删除操作，反之，每一个删除操作都要等待对应的插入操作。如果使用**SychronousQueue**，则提交的任务不会被真实的保持，而总是将新任务提交给线程执行，如果没有空闲线程，则尝试创建新线程，如果线程数量已经达到最大值，则执行拒绝策略。因此，使用**SychronousQueue**队列，通常要设置很大的**maximumPoolSize**值，否则很容易执行拒绝策略。

有界的任务队列：有界的任务队列可使用**ArrayBlockingQueue**类实现，**ArrayBlockingQueue**类的构造函数必须带 一个容量参数，表示该队列的最大容量：

```java
public ArrayBlockingQueue(int capacity)
```

当使用有界队列时，若有新的任务需要执行，如果线程池的实际线程数小于**corePoolSize**，则会有限创建新的线程，若大于**corePoolSize**，则会将新任务加入等待队列。若等待队列已满，无法加入，则在总线程数不大于**maximumPoolSize**的前提下，创建新的线程执行任务。若大于**maximumPoolSize**，则执行拒绝策略。可见，有界队列仅当在任务队列装满时，才能将线程数提升到**corePoolSize**以上，换言之，除非系统非常繁忙，否则要确保核心线程数维持在**corePoolSize**。

无界的任务队列：无界任务队列可以通过**LinkedBlockingQueue**类实现。与有界队列相比，除非系统资源耗尽，否则无界的任务队列不存在任务对队失败的情况。当有新的任务到来，系统的线程数小于**corePoolSize**时，线程池会生成新的线程执行任务，但当系统的线程数达到**corePoolSize**，就不会继续增加了。若后续有新的任务加入，而又没有空闲的线程资源，则任务直接进入队列等待。若任务创建和处理的速度差异很大，无界队列会保持快速增长，直到耗尽系统内存。

优先任务队列：优先任务队列是带有执行优先级的队列。它通过**PriorityBlockingQueue**类实现，可以控制任务的执行先后顺序。它是一个特殊的无界队列。无论是有界队列**ArrayBlockingQueue**类，还是未指定大小的无界队列**LinkedBlockingQueue**类都是按照先进先出算法处理任务的。而**PriorityBlockingQueue**类则可以根据任务自身的优先级顺序先后执行，在确保系统性能的同时，也能有很好的质量保证。

回顾`newFixedThreadPool()`方法的实现，它返回了一个**corePoolSize**和**maximumPoolSize**大小一样的，并且使用了**LinkedBlockingQueue**任务队列的线程池。因为对于固定大小的线程池而言，不存在线程数量的动态变化，因此**corePoolSize**和**maximumPoolSize**可以相等。同时，它使用无界队列存放无法立即执行的任务，当任务提交非常频繁的时候，该队列可能迅速膨胀，从而耗尽系统资源。

`newSingleThreadExecutor()`方法返回的单线程线程池，是`newFixedThreadPool()`方法的一种退化，只是简单地将线程池线程数量设置为1。

`newCachedThreadPool()`方法返回**corePoolSize**为**0**，**maximumPoolSize**无穷大的线程池，这意味着在没有任务时，该线程池内无线程，而当任务被提交时，该线程池会使用空闲的线程执行任务，若无空闲线程，则将任务加入**SynchronousQueue**队列，而**SynchronousQueue**队列是一种直接提交的队列，它总会迫使线程池增加新的线程执行任务。当任务执行完毕后，由于**corePoolSize**为0，因此空闲线程又会在指定时间内（60秒）被回收。

对于`newCachedThreadPool()`方法，如果同时有大量任务被提交，而任务的执行又不那么快时，那么系统便会开启等量的线程处理，这样做可能很快耗尽系统的资源。

这里给出**ThreadPoolExecutor**线程池的核心调度代码，这段代码也充分体现了上述线程池的工作逻辑。

```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```

代码第5行的`workerCountOf()`函数取得了当前线程池的线程总数。当线程总数小于**corePoolSize**核心线程数时，会将任务通过addWorker()方法直接调度执行。否则，则在第10行代码处（`workQueue.offer()`）进入等待队列。如果进入等待队列失败（比如有界队列到达了上限，或者使用了**SynchronousQueue**类），则会执行第17行，将任务直接提交给线程池。如果当前线程数已经达到**maximumPoolSize**，则提交失败，就执行第18行的拒绝策略。

## 拒绝策略

**THreadPoolExecutor**类的最后一个参数指定了拒绝策略。也就是当任务数量超过系统实际承载能力时，就要用到拒绝策略。拒绝策略可以说是系统超负荷运行时的补救措施，通常由于压力太大引起的，也就是线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列中也已经排满了，再也放不下新任务了。这时，我们就需要有一套机制合理的处理这个问题。

JDK内置的拒绝策略如下：

- **AbortPolicy**策略：该策略会直接抛出异常，阻止系统正常工作。

- **CallerRunsPolicy**策略：只要线程池未关闭，该策略直接在调用着线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。

- **DiscardOldestPolicy**策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。

- **DiscardPolicy**策略：该策略默默地丢弃无法处理的任务，不予任务处理。如果允许任务丢失，我觉得这可能是最好的一种方案。

以上内置的策略均实现了**RejectedExecutionHandler**接口。若以上策略无法满足实际应用的需要，完全可以自己扩展**RejectedExecutionHandler**接口。**RejectedExecutionHandler**的定义如下：

```java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

其中**r**为请求执行的任务，**executor**为当前的线程池。