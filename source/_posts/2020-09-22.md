---
title: Java8的Stream流详解
tags: 
    - java
    - 面试
date: 2020-09-22
cover: https://coderhch.oss-cn-shanghai.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87/2020_02_17_00_41_IMG_0941.JPG
---
# Java8的Stream流详解

一、 流的生成方法

1. Collection接口的stream()或parallelStream()方法
2. 静态的Stream.of()、Stream.empty()方法
3. Arrays.stream(array, from, to)
4. 静态的Stream.generate()方法生成无限流，接受一个不包含引元的函数
5. 静态的Stream.iterate()方法生成无限流，接受一个种子值以及一个迭代函数
6. Pattern接口的splitAsStream(input)方法
7. 静态的Files.lines(path)、Files.lines(path, charSet)方法
8. 静态的Stream.concat()方法将两个流连接起来

二、 流的Intermediate方法(中间操作)

1. filter(Predicate)
   将结果为false的元素过滤掉

```java
List<String> strings = Stream.of("a","1abc","abc1").filter(value -> value.startsWith("a")).collect(Collectors.toList());
```

2. map(fun)
   转换元素的值，可以用方法引元或者lambda表达式

```java
List<String> strings = Stream.of("a","b","hello").map(string -> string.toUpperCase()).collect(Collectors.toList());
```

3. flatMap(fun)
   若元素是流，将流摊平为正常元素，再进行元素转换

```java
 List<Integer> collect = Stream.of(Arrays.asList(1, 2), Arrays.asList(3, 4))
                .flatMap(numbers -> numbers.stream()).collect(Collectors.toList());
```

4. limit(n)
   保留前n个元素

```java
List<String> strings = Stream.of("a","1abc","abc1","124").limit(3).collect(Collectors.toList());
```

5. skip(n)
   跳过前n个元素

```java
List<String> strings = Stream.of("a","1abc","abc1","124").skip(2).collect(Collectors.toList());
```

6. distinct()
   剔除重复元素

```java
List<String> strings = Stream.of("a","1abc","abc1","124").distinct().collect(Collectors.toList());
```

7. sorted()
   将Comparable元素的流排序

```java
List<String> strings = Stream.of("a","1abc","abc1","124").sorted().collect(Collectors.toList());
```

8. sorted(Comparator)
   将流元素按Comparator排序

```java
List<String> strings = Stream.of("a","1abc","abc1","124").sorted((string1,string2)->{
    if (string1.toCharArray().length<string2.toCharArray().length){
        return 1;
    }else if (string1.toCharArray().length>string2.toCharArray().length){
        return -1;
    }else {
        return 0;
    }
}).collect(Collectors.toList());
```

9. peek(fun)
   流不变，但会把每个元素传入fun执行，可以用作调试

```java
List<String> strings = Stream.of("a","1abc","abc1","124").peek(x-> System.out.println(x+x)).collect(Collectors.toList());
```

三、 流的Terminal方法(终结操作)

- 约简操作

  1. max(Comparator)

  ```java
  Optional<String> max = Stream.of("a", "1abc", "abc1", "124").max((string1, string2) -> {
      if (string1.toCharArray().length > string2.toCharArray().length) {
          return 1;
      } else if (string1.toCharArray().length < string2.toCharArray().length) {
          return -1;
      } else {
          return 0;
      }
  });
  ```

  2. min(Comparator)

  ```java
  Optional<String> max = Stream.of("a", "1abc", "abc1", "124").min((string1, string2) -> {
      if (string1.toCharArray().length > string2.toCharArray().length) {
          return 1;
      } else if (string1.toCharArray().length < string2.toCharArray().length) {
          return -1;
      } else {
          return 0;
      }
  });
  ```

  3. count()

  ```java
  long count = Stream.of("a", "1abc", "abc1", "124").count();
  ```

  4. findFirst()
     返回第一个元素

  ```java
  Optional<String> first = Stream.of("a", "1abc", "abc1", "124").findFirst();
  ```

  5. findAny()
     返回任意元素

  ```java
  Optional<String> findAny = Stream.of("a", "1abc", "abc1", "124").findAny();
  ```

  6. anyMatch(Predicate)
     任意元素匹配时返回true

  ```java
  boolean b = Stream.of("a", "1abc", "abc1", "124").anyMatch(string -> string.startsWith("a"));
  ```

  7. allMatch(Predicate)
     所有元素匹配时返回true

  ```java
  boolean b = Stream.of("a", "1abc", "abc1", "124").allMatch(string -> string.startsWith("a"));
  ```

  8. noneMatch(Predicate)
     没有元素匹配时返回true

  ```java
  boolean b = Stream.of("a", "1abc", "abc1", "124").noneMatch(string -> string.startsWith("a"));
  ```

  9. reduce(fun)
     从流中计算某个值，接受一个二元函数作为累积器，从前两个元素开始持续应用它，累积器的中间结果作为第一个参数，流元素作为第二个参数

  ```java
  Optional<Integer> reduce = Stream.of(1, 2, 3).reduce((acc, element) -> acc + element);
  ```

  10. reduce(a, fun)
      a为幺元值，作为累积器的起点

  ```java
  Integer reduce = Stream.of(1, 2, 3).reduce(0, (acc, element) -> acc + element);
  ```

  11. reduce(a, fun1, fun2)
      与二元变形类似，并发操作中，当累积器的第一个参数与第二个参数都为流元素类型时，可以对各个中间结果也应用累积器进行合并，但是当累积器的第一个参数不是流元素类型而是类型T的时候，各个中间结果也为类型T，需要fun2来将各个中间结果进行合并